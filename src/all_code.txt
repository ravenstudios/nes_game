===== animate.asm =====
 ; timer
 ANITMATION:
    INC anim_timer
    LDA anim_timer
    CMP #ANIM_SPEED
    BCC @pass            ; < speed? don’t advance frame

    ; advance frame
    LDA #0
    STA anim_timer
    LDA anim_frame
    CLC
    ADC #1
    CMP #NUM_FRAMES
    BCC @store_frame
    LDA #0
@store_frame:
    STA anim_frame
@pass:
    RTS
===== audio.asm =====
; ===== audio.asm =====
; simple thunder SFX using the noise channel

; ZP vars (we’ll add them to zeropage.asm in a sec)
;   thunder_active
;   thunder_timer

StartThunder:
    ; configure noise channel
    ; $400C: DDLC VVVV
    ; D = length counter halt, L = constant volume, V = volume
    LDA #%00101111        ; length halt=0, const volume=1, volume=15
    STA $400C

    ; $400E: ---- PPPP  (period index, lower = lower pitch)
    LDA #%00000001        ; low, rumbly noise
    STA $400E

    ; $400F: LLLL L--- (length counter, but we’re going to stop manually)
    LDA #$00
    STA $400F

    ; enable noise channel (bit 3) in $4015
    LDA #%00001000
    STA $4015

    ; how long the thunder lasts (frames)
    LDA #60               ; ~1 second at 60 FPS
    STA thunder_timer

    LDA #$01
    STA thunder_active
    RTS


UpdateThunder:
    LDA thunder_active
    BEQ @done

    DEC thunder_timer
    BNE @done

    ; time’s up – silence noise
    LDA #$00
    STA $4015        ; no channels enabled (fine for now)
    LDA #$00
    STA thunder_active

@done:
    RTS

===== background.asm =====


; LOADBACKGROUND:

; 	LDA $2002		;read PPU status to reset high/low latch
; 	LDA #$20	;start of nametable "canvas" as the high bit
; 	STA $2006	
; 	LDA #$00	;sets low bit
; 	STA $2006	;what adress to write to starting at $2100
; 	LDX #$00	;bad code that uses wraparound to hit 0 in the loop
; LOADBACKGROUNDP1:
; 	LDA BACKGROUNDDATA, X ;loop through BACKGROUNDDATA
; 	STA $2007 ; store byte
; 	LDA COLLISIONTABLEDATA, X
; 	; STA COLLISIONTABLE
; 	INX
; 	CPX #$00 ;wrap around
; 	BNE LOADBACKGROUNDP1 ; if x == 0 break
; LOADBACKGROUNDP2:
; 	LDA BACKGROUNDDATA+256, X
; 	STA $2007
; 	LDA COLLISIONTABLEDATA+256, X
; 	; STA COLLISIONTABLE
; 	INX
; 	CPX #$00
; 	BNE LOADBACKGROUNDP2
; LOADBACKGROUNDP3:
; 	LDA BACKGROUNDDATA+512, X
; 	STA $2007
; 	LDA COLLISIONTABLEDATA+512, X
; 	; STA COLLISIONTABLE
; 	INX
; 	CPX #$00
; 	BNE LOADBACKGROUNDP3
; LOADBACKGROUNDP4:
; 	LDA BACKGROUNDDATA+768, X
; 	STA $2007
; 	LDA COLLISIONTABLEDATA+768, X
; 	; STA COLLISIONTABLE
; 	INX
; 	CPX #$c0
; 	BNE LOADBACKGROUNDP4
; ;192

; ;LOAD BACKGROUND PALETTEDATA
; 	LDA #$23	
; 	STA $2006
; 	LDA #$c0
; 	STA $2006
; 	LDX #$00
; LOADBACKGROUNDATTRDATA:
; 	LDA BACKGROUNDATTRDATA, X
; 	STA $2007
; 	INX
; 	CPX #$40
; 	BNE LOADBACKGROUNDATTRDATA

; 	;RESET SCROLL
; 	LDA #$00
; 	STA $2005
; 	STA $2005



; RTS
	

SetTilePushable:
	TYA
	LSR
	LSR
	LSR
	LSR                  ; A = y_tile (0..14)
	ASL
	ASL
	ASL
	ASL                  ; A = y_tile * 16
	STA tmp              ; tmp = row offset

	TXA
	LSR
	LSR
	LSR
	LSR                  ; A = x_tile (0..15)
	CLC
	ADC tmp              ; A = index (0..239)
	TAX

	LDA #$02             ; e.g., 2 = pushable block (or 1 if you treat it as solid)
	STA COLLISIONTABLE,X
	RTS


; Clear the collision tile we just checked in CheckTile
UnsetTileSolid:
    TAX
    LDA #$00
    STA COLLISIONTABLE, X
    RTS


SetTileSolid1:
    TAX
    LDA #$01
    STA COLLISIONTABLE, X
    RTS



SetTileDoor:

	TYA
	LSR
	LSR
	LSR
	LSR                  ; A = y_tile (0..14)
	ASL
	ASL
	ASL
	ASL                  ; A = y_tile * 16
	STA tmp              ; tmp = row offset

	TXA
	LSR
	LSR
	LSR
	LSR                  ; A = x_tile (0..15)
	CLC
	ADC tmp              ; A = index (0..239)
	TAX

	LDA #$03         ; e.g., 2 = pushable block (or 1 if you treat it as solid)
	STA COLLISIONTABLE,X
	RTS

UnsetTileDoor:

	TYA
	LSR
	LSR
	LSR
	LSR                  ; A = y_tile (0..14)
	ASL
	ASL
	ASL
	ASL                  ; A = y_tile * 16
	STA tmp              ; tmp = row offset

	TXA
	LSR
	LSR
	LSR
	LSR                  ; A = x_tile (0..15)
	CLC
	ADC tmp              ; A = index (0..239)
	TAX

	LDA #$01        ; e.g., 2 = pushable block (or 1 if you treat it as solid)
	STA COLLISIONTABLE,X
	RTS



PALETTEDATA:
.byte $0f, $27, $13, $0f
.byte $20, $0A, $15, $01
.byte $20, $29, $28, $27
.byte $20, $34, $24, $14
;sprite palettes
.byte $0f, $27, $13, $0f ;shouold be sprite but changing this changes
.byte $20, $20, $11, $30
.byte $20, $20, $30, $27
.byte $20, $3C, $2C, $1C 	;background palettes

BACKGROUNDDATA:

.byte $EC,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EB,$EA
.byte $E8,$FF,$CB,$C8,$D5,$C4,$D2,$FF,$FF,$FF,$FF,$FF,$FF,$CB,$C4,$D5,$C4,$CB,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$E3,$FF,$FF,$E9
.byte $E7,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E6,$E5
.byte $4B,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4E,$4F
.byte $5B,$5C,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5D,$5E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$04,$05,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$14,$15,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $5B,$6C,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$F4,$6E,$7F
.byte $7B,$7C,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7D,$7E,$7F
.byte $8B,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8C,$8F

;0-blue
;1-green
;2-yellow
;3-pink
;br - bl - tr - tl

; BACKGROUNDATTRDATA:
;   .byte $01, $01, $01, $01, $01, $01, $01, $01
; 	.byte $01, $01, $01, $01, $01, $01, $01, $01
; 	.byte $00, $00, $00, $00, $00, $00, $00, $00
; 	.byte $00, $00, $00, $00, $00, $00, $00, $00
; 	.byte $00, $00, $00, $00, $00, $00, $00, $00
; 	.byte $00, $00, $00, $00, $00, $00, $00, $00
; 	.byte $00, $00, $00, $00, $00, $00, $00, $00
; 	.byte $00, $00, $00, $00, $00, $00, $00, $00


COLLISIONTABLEDATA:
	

.byte $01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01
.byte $01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01
.byte $01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01
.byte $01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$00,$00,$01,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00,$01
.byte $01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01
.byte $01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01
	

; LoadCollisionTable:
;     LDX #$00
; @copy:
;     CPX #240            ; 16*15
;     BEQ @done
;     LDA COLLISIONTABLEDATA, X
;     STA COLLISIONTABLE, X
;     INX
;     BNE @copy
; @done:
;     RTS



; tmp0/tmp1 are 16-bit scratch in zeropage (low/high)
; A=tile, X=col, Y=row

; A=tile, X=col, Y=row
; A = tile, X = col (0..31), Y = row (0..29)
; expects:
;   loadedTile = tile number
;   X = column (0–31)
;   Y = row (0–29)
; uses:
;   tmp0/tmp1

SetBGTile:
    ; addr = $2000 + row*32 + col
    TYA
    STA tmp0
    LDA #$00
    STA tmp1

    ; tmp = row * 32
    ASL tmp0       ; *2
    ROL tmp1
    ASL tmp0       ; *4
    ROL tmp1
    ASL tmp0       ; *8
    ROL tmp1
    ASL tmp0       ; *16
    ROL tmp1
    ASL tmp0       ; *32
    ROL tmp1

    CLC
    LDA tmp0
    ADC #<$2000
    STA tmp0
    LDA tmp1
    ADC #>$2000
    STA tmp1

    ; add column X
    TXA
    CLC
    ADC tmp0
    STA tmp0
    LDA tmp1
    ADC #$00
    STA tmp1

    ; ---- do the write ----
    LDA $2002          ; reset PPUADDR latch (same as BIT $2002)
    LDA tmp1
    STA $2006          ; high byte
    LDA tmp0
    STA $2006          ; low byte

    LDA loadedTile
    STA $2007
; 
	LDA #$00
    STA $2005
    STA $2005
	
    RTS



ClearBackground:
    ; disable rendering
    LDA #$00
    STA $2001

    ; set VRAM addr = $2000
    LDA $2002
    LDA #$20
    STA $2006
    LDA #$00
    STA $2006

    ; 960 bytes = $03C0
    LDY #$03       ; high byte
    LDX #$C0       ; low byte
ClearLoop:
    LDA #$00
    STA $2007      ; write blank tile

    DEX
    BNE ClearLoop  ; loop until X wraps to 0

    DEY
    BPL ClearLoop  ; run for Y = 3,2,1,0 (stop when Y becomes $FF)

    ; re-enable rendering
    LDA #%00011110
    STA $2001
    RTS





ClearOAM:
	LDA #$FF
	LDX #$00
	@loop:
    STA $0200, X
    INX
    BNE @loop
	RTS
===== bullet.asm =====



DrawBullet:
; LDA is_bullet_active
;     BEQ @done


    LDA bullet_y        ; Y position on screen (80 decimal)
    STA BULLET_OAM         ; BULLET_OAM[0]

    LDA #BULLET_TILE        ; Tile index (from your CHR)
    STA BULLET_OAM+1       ; BULLET_OAM[1]

    LDA #$00        ; Attributes (palette 0, not flipped)
    STA BULLET_OAM+2       ; BULLET_OAM[2]

    LDA bullet_x        ; X position (80 decimal)
    STA BULLET_OAM+3       ; BULLET_OAM[3]


    @done:
    RTS

UpdateBulet:
    LDA is_bullet_active
    BEQ @done

    JSR BulletHitSolid

    LDA bullet_x
    CMP #$f0 ; offscreen
    BCS DeactivateBullet

    LDA bullet_y
    CMP #$ef ; offscreen
    BCS DeactivateBullet

    LDA is_bullet_active
    BEQ @done
    ;move
    LDA bullet_direction
    CMP #FACINGUP
    BEQ @up
    CMP #FACINGDOWN
    BEQ @down
    CMP #FACINGLEFT
    BEQ @left
    CMP #FACINGRIGHT
    BEQ @right
    @up:
    LDA bullet_y
    SEC
    SBC #BULLET_SPEED
    STA bullet_y
    RTS

    @down:
    LDA bullet_y
    CLC
    ADC #BULLET_SPEED
    STA bullet_y
    RTS

    @left:
    LDA bullet_x
    SEC
    SBC #BULLET_SPEED
    STA bullet_x
    RTS

    @right:
    LDA bullet_x
    CLC
    ADC #BULLET_SPEED
    STA bullet_x
    RTS


@done:
    
    RTS

DeactivateBullet:
    LDA #$F0
    STA bullet_y
    LDA #$00
    STA bullet_x
    STA is_bullet_active
    RTS


; -------------------------------------------------------
; BulletHitSolid
; Checks the tile in front of the bullet (edge midpoint).
; If that tile is non-zero in COLLISIONTABLE → deactivate.
; Uses: A,X. Temps: tmpx,tmpy,tile_x,tile_y
; Expects: bullet_x, bullet_y, bullet_direction
; -------------------------------------------------------
BulletHitSolid:
    LDA is_bullet_active
    BNE :+
        RTS              ; inactive → nothing to do
:
    ; choose probe point (front edge midpoint)
    LDA bullet_direction
    CMP #FACINGRIGHT
    BEQ @probe_right
    CMP #FACINGLEFT
    BEQ @probe_left
    CMP #FACINGDOWN
    BEQ @probe_down
    ; default = up
@probe_up:
    ; x + 4, y - 1
    LDA bullet_x
    CLC
    ADC #4
    STA tmpx
    LDA bullet_y
    SEC
    SBC #1
    STA tmpy
    JMP @to_index

@probe_down:
    ; x + 4, y + 8
    LDA bullet_x
    CLC
    ADC #4
    STA tmpx
    LDA bullet_y
    CLC
    ADC #8
    STA tmpy
    JMP @to_index

@probe_left:
    ; x - 1, y + 4
    LDA bullet_x
    SEC
    SBC #1
    STA tmpx
    LDA bullet_y
    CLC
    ADC #4
    STA tmpy
    JMP @to_index

@probe_right:
    ; x + 8, y + 4
    LDA bullet_x
    CLC
    ADC #8
    STA tmpx
    LDA bullet_y
    CLC
    ADC #4
    STA tmpy
    ; fallthrough

@to_index:
    ; tile_x = tmpx >> 4 ; tile_y = tmpy >> 4
    LDA tmpx
    LSR
    LSR
    LSR
    LSR
    STA tile_x

    LDA tmpy
    LSR
    LSR
    LSR
    LSR
    STA tile_y

    ; X = tile_y*16 + tile_x
    LDA tile_y
    ASL
    ASL
    ASL
    ASL              ; *16
    CLC
    ADC tile_x
    TAX

    ; nonzero = blocked/solid (treat 1 and 2 as solid)
    LDA COLLISIONTABLE, X
    BEQ @clear
    ; hit something → deactivate bullet
    JSR DeactivateBullet
@clear:
    RTS


===== chaser.asm =====




CHASERENEMYWALK:
    ; -------- HORIZONTAL --------
    LDA player_x
    CMP CHASERENEMY_X
    BEQ @VERT                   ; same column → skip horizontal

    BCC @GO_LEFT                ; player_x < enemy_x → go left

    ; go RIGHT
    LDA #FACINGRIGHT
    STA CHASERENEMYDIRECTION
    JSR LoadChaserCollisionValues
    JSR TileCollision
    BCS @bump_left                ; blocked → skip move
    INC CHASERENEMY_X
    JMP @VERT

@bump_left:
    DEC CHASERENEMY_X
    JMP @VERT


@GO_LEFT:
    LDA #FACINGLEFT
    STA CHASERENEMYDIRECTION
    JSR LoadChaserCollisionValues
    JSR TileCollision
    BCS @bump_right
    DEC CHASERENEMY_X
    JMP @VERT


@bump_right:
    INC CHASERENEMY_X
    JMP @VERT
@VERT:
    ; -------- VERTICAL --------
    LDA player_y
    CMP CHASERENEMY_Y
    BEQ @DONE                   ; same row → skip vertical

    BCC @GO_UP                  ; player_y < enemy_y → go up

    ; go DOWN
    LDA #FACINGDOWN
    STA CHASERENEMYDIRECTION
    JSR LoadChaserCollisionValues
    JSR TileCollision
    BCS @bump_up
    INC CHASERENEMY_Y
    JMP @DONE

@bump_up:
    DEC CHASERENEMY_Y
    JMP @DONE

@GO_UP:
    LDA #FACINGUP
    STA CHASERENEMYDIRECTION
    JSR LoadChaserCollisionValues
    JSR TileCollision
    BCS @bump_down
    DEC CHASERENEMY_Y
    JMP @DONE

@bump_down:
    INC CHASERENEMY_Y
    JMP @DONE

    
@DONE:
    RTS


DRAWCHASERENEMY:

	LDA anim_frame
    ASL A
    CLC
    ADC #$08
    ADC enemy_direction
    TAX                        ; X = frame_base
    
    ; write TILE bytes ONLY
    STX $0221                  ; TL
    INX
    STX $0225                  ; TR
    TXA
    CLC
    ADC #15
    TAX
    STX $0229               ; BL
    INX
    STX $022d               ; BR    

    
    

        ; write X
    LDA CHASERENEMY_X
    STA $0223
    STA $022b
    CLC
    ADC #8
    STA $0227
    STA $022f

    ; write Y
    LDA CHASERENEMY_Y
    STA $0220
    STA $0224
    CLC
    ADC #8
    STA $0228
    STA $022c

    RTS



LoadChaserCollisionValues:
    LDA CHASERENEMY_X
    STA collision_check_x
    LDA CHASERENEMY_Y
    STA collision_check_y

    LDA CHASERDIRECTION
    STA collision_check_dir
RTS
===== collision.asm =====
;-----------------------Tile Collision------------------------------
TileCollision:

LDA collision_check_dir
CMP #FACINGUP
BEQ @up

CMP #FACINGDOWN
BEQ @down

CMP #FACINGLEFT
BEQ @left

CMP #FACINGRIGHT
BEQ @right
CLC
RTS


;all collision_check_vars are loaded before calling this sub routine
@up:
    ;tl
    LDA collision_check_y
    SEC
    SBC #01
    STA collision_check_y
    JSR CheckTile
    BCS @yesCollision
    ;tr
    LDA collision_check_x
    CLC
    ADC #WIDTH
    SEC
    SBC #01
    STA collision_check_x
    JSR CheckTile
    BCS @yesCollision
    
    CLC
    RTS

@down:
    ;bl
    LDA collision_check_y
    CLC
    ADC #HEIGHT
    ADC #01
    STA collision_check_y
    JSR CheckTile
    BCS @yesCollision
    ;br
    LDA collision_check_x
    CLC
    ADC #WIDTH
    SEC
    SBC #01
    STA collision_check_x
    JSR CheckTile
    BCS @yesCollision
    
    CLC
    RTS

@yesCollision:
    SEC
    RTS

@noCollision:
    CLC
    RTS


@left:
    ;tl
    LDA collision_check_x
    SEC
    SBC #$01
    STA collision_check_x
    JSR CheckTile
    BCS @yesCollision
    ;bl
    LDA collision_check_y
    CLC
    ADC #HEIGHT
    SEC
    SBC #01
    STA collision_check_y
    JSR CheckTile
    BCS @yesCollision
    
    CLC
    RTS

@right:
    ;tr
    LDA collision_check_x
    CLC
    ADC #WIDTH
    CLC
    ; ADC #$01
    STA collision_check_x
    JSR CheckTile
    BCS @yesCollision
    ;br
    LDA collision_check_y
    CLC
    ADC #HEIGHT
    SEC
    SBC #01
    STA collision_check_y
    JSR CheckTile
    BCS @yesCollision
    
    CLC
    RTS


@done:
    RTS

CheckTile:
    ; x>>4, y>>4 -> index in X (unchanged from your code)
    LDA collision_check_x
    LSR
    LSR
    LSR
    LSR
    STA tile_x

    LDA collision_check_y
    LSR
    LSR
    LSR
    LSR
    STA tile_y

    ; index = y*16 + x  (to X)
    LDA tile_y
    ASL
    ASL
    ASL
    ASL
    CLC
    ADC tile_x
    TAX

    ; --- read tile once and keep it ---
    LDA COLLISIONTABLE, X
    STA cur_tile           ; <- NEW: remember tile value
    
    ; ---------- Door (tile = 3) ----------
    LDA cur_tile
    CMP #$03
    BNE :+
        LDA is_player_checking
        BEQ @decide_solid
        JSR Exit
        CLC                 ; usually treat as passable after teleport
        RTS
:

    ; ---------- Pushable (tile = 2) ----------
    LDA cur_tile
    CMP #$02
    
    BNE @decide_solid 
        STX movable_block_index      
        
        
        JSR MoveBlock






@decide_solid:
    ; ---------- Final solidity decision from tile value ----------
    LDA cur_tile           ; <- use the cached tile value
    CMP #$01               ; 1 = solid wall?
    BEQ @solid
    CLC                    ; anything else (0=empty, etc.) → no collision
    RTS
@solid:
    SEC
    RTS




; ---- Tile-range overlap on a 16x15 grid -----------------------
; collide_check_1x/1y/1w/1h = box1 (player)
; collide_check_2x/2y/2w/2h = box2 (block)
; Assumes WIDTH/HEIGHT are constants (e.g., 16). For general sizes,
; replace +15 with +(WIDTH-1)/(HEIGHT-1) immediates.
; OUT: C=1 overlap, C=0 no overlap

; temps (ZP recommended)


; assumes WIDTH and HEIGHT are constants for BOTH boxes
; OUT: C=1 overlap, C=0 no overlap
CheckCollision:
    ; box1 X
    LDA collide_check_1x
    LSR
    LSR
    LSR
    LSR
    STA t1_minx
    LDA collide_check_1x
    CLC
    ADC #(WIDTH-1)      ; <-- not hard-coded 15 unless WIDTH=16
    LSR
    LSR
    LSR
    LSR
    STA t1_maxx

    ; box1 Y
    LDA collide_check_1y
    LSR
    LSR
    LSR
    LSR
    STA t1_miny
    LDA collide_check_1y
    CLC
    ADC #(HEIGHT-1)
    LSR
    LSR
    LSR
    LSR
    STA t1_maxy

    ; box2 X
    LDA collide_check_2x
    LSR
    LSR
    LSR
    LSR
    STA t2_minx
    LDA collide_check_2x
    CLC
    ADC #(WIDTH-1)
    LSR
    LSR
    LSR
    LSR
    STA t2_maxx

    ; box2 Y
    LDA collide_check_2y
    LSR
    LSR
    LSR
    LSR
    STA t2_miny
    LDA collide_check_2y
    CLC
    ADC #(HEIGHT-1)
    LSR
    LSR
    LSR
    LSR
    STA t2_maxy

    ; no-overlap tests
    LDA t1_maxx
    CMP t2_minx
    BCC @no_hit

    LDA t2_maxx
    CMP t1_minx
    BCC @no_hit

    LDA t1_maxy
    CMP t2_miny
    BCC @no_hit

    LDA t2_maxy
    CMP t1_miny
    BCC @no_hit

    SEC
    RTS
@no_hit:
    CLC
    RTS

Exit:
    ; close the door in the current room *before* leaving
    ; LDA #$01
    ; STA can_undraw_door
    ; JSR Undraw_door

    ; move player to start position for the *next* room
    LDA #PLAYER_X_START
    STA player_x
    LDA #PLAYER_Y_START
    STA player_y

    ; decide what the next level is
    LDX level
    INX
    STX next_level      ; store next room index

    ; start transition: phase 1 = flicker off
    LDA #$01
    STA transition_phase

    LDA #16             ; number of flicker frames
    STA transition_frames

    ; JSR StartThunder


    ; lock the door for next time in logic
    LDA #$00
    STA is_door_unlocked
    STA door_draw_pending
    ; make sure this flag is not left dangling
    ; LDA #$01
    ; STA can_undraw_door
    
    RTS





===== door.asm =====
DoorData:
    .byte $0d, $0e, $1d, $1e
DoorLocation:
    .word $208C, $208D, $20aC, $20aD
WallData:
    .byte $4d, $4d, $5d, $5d

PPUSTATUS = $2002
PPUADDR   = $2006
PPUDATA   = $2007


; DoorData was:  $0d, $0e, $1d, $1e
; WallData was:  $4d, $4d, $5d, $5d

; DOOR_TILE_X = 12
; DOOR_TILE_Y = 4

DrawDoor:
    LDA door_draw_pending
    CMP #$01
    BNE @done

    LDA #$00
    STA door_draw_pending ;reset flag

    ; TL
    LDA #$0d
    STA loadedTile
    LDX #DOOR_TILE_X
    LDY #DOOR_TILE_Y
    JSR SetBGTile

    ; TR
    LDA #$0e
    STA loadedTile
    LDX #DOOR_TILE_X+1
    LDY #DOOR_TILE_Y
    JSR SetBGTile

    ; BL
    LDA #$1d
    STA loadedTile
    LDX #DOOR_TILE_X
    LDY #DOOR_TILE_Y+1
    JSR SetBGTile

    ; BR
    LDA #$1e
    STA loadedTile
    LDX #DOOR_TILE_X+1
    LDY #DOOR_TILE_Y+1
    JSR SetBGTile

    ; update collision table for the top row (like you do now)
    LDX #$60       ; pixel X = $60
    LDY #$20       ; pixel Y = $20
    JSR SetTileDoor
    INX
    JSR SetTileDoor
    
@done:
    RTS



Undraw_door:
    LDA can_undraw_door
    CMP #$01
    BNE @done
    LDA #$00
    STA can_undraw_door; reset flag

    ; TL

    LDA #$4d
    STA loadedTile
    LDX #DOOR_TILE_X
    LDY #DOOR_TILE_Y
    JSR SetBGTile

    ; TR
    LDA #$4d
    STA loadedTile
    LDX #DOOR_TILE_X+1
    LDY #DOOR_TILE_Y
    JSR SetBGTile

    ; BL
    LDA #$5d
    STA loadedTile
    LDX #DOOR_TILE_X
    LDY #DOOR_TILE_Y+1
    JSR SetBGTile

    ; BR
    LDA #$5d
    STA loadedTile
    LDX #DOOR_TILE_X+1
    LDY #DOOR_TILE_Y+1
    JSR SetBGTile

    ; update collision table for the top row (like you do now)
    LDX #$60       ; pixel X = $60
    LDY #$20       ; pixel Y = $20
    JSR UnsetTileDoor
    INX
    JSR UnsetTileDoor

    
@done:
    RTS


DoorUpdate:
    LDA is_door_unlocked
    CMP #$01
    BEQ @done
        LDA player_y
        LSR
        LSR
        LSR
        LSR         ; A = tile_y
        STA tile_y

        LDA player_x
        LSR
        LSR
        LSR
        LSR         ; A = tile_x
        STA tile_x

        LDA tile_y
        ASL
        ASL
        ASL
        ASL         ; A = y*16
        CLC
        ADC tile_x


        CMP secret_tile
        BNE @done
            LDA #$01
            STA is_door_unlocked
            STA door_draw_pending
            LDA #$00
            STA can_undraw_door

            ; JSR DrawDoor

@done:
RTS
===== enemy.asm =====

EnemyUpdate:
    LDA #$00
    STA enemy_loop_idx
@loop_enemies:
    
    LDX enemy_loop_idx
    CPX enemy_count
    BCS @done


    LDA is_enemy_active, X
    BEQ @advance

    lDA is_bullet_active
    BEQ :+
    JSR BulletVsEnemyOverlap
    :



    LDA enemy_direction, X

    CMP #FACINGUP
    BEQ @move_up

    CMP #FACINGDOWN
    BEQ @move_down
    
    CMP #FACINGLEFT
    BEQ @move_left

    CMP #FACINGRIGHT
    BEQ @move_right
     JMP @advance


@done:
    LDA #$00
    STA enemy_loop_idx
    RTS

 @advance:
    INC enemy_loop_idx
    JMP @loop_enemies



@move_up:
TXA
PHA
TYA
PHA
JSR LoadEnemyCollisionValues   ; OK if uses A only
LDA #$00
STA is_player_checking
JSR TileCollision              ; this will clobber X/Y

PLA
TAY
PLA
TAX
    BCS  @change_direction
    DEC enemy_y, X
     JMP @advance
    
@move_down:
TXA
PHA
TYA
PHA

JSR LoadEnemyCollisionValues   ; OK if uses A only
LDA #$00
STA is_player_checking
JSR TileCollision              ; this will clobber X/Y

PLA
TAY
PLA
TAX
    BCS @change_direction
    INC enemy_y, X
 JMP @advance
@move_left:
TXA
PHA
TYA
PHA
JSR LoadEnemyCollisionValues   ; OK if uses A only
LDA #$00
STA is_player_checking
JSR TileCollision              ; this will clobber X/Y

PLA
TAY
PLA
TAX
    BCS @change_direction
    DEC enemy_x, X
 JMP @advance
@move_right:
TXA
PHA
TYA
PHA
JSR LoadEnemyCollisionValues   ; OK if uses A only
LDA #$00
STA is_player_checking
JSR TileCollision              ; this will clobber X/Y

PLA
TAY
PLA
TAX
    BCS @change_direction
    INC enemy_x, X
 JMP @advance



@change_direction:
    LDX enemy_loop_idx
    LDA enemy_direction, X

    CMP #FACINGUP
    BEQ @push_down

    CMP #FACINGDOWN
    BEQ @push_up
    
    CMP #FACINGLEFT
    BEQ @push_right

    CMP #FACINGRIGHT
    BEQ @push_left

     JMP @advance

@push_up:
    DEC enemy_y, X
    JSR GetRandomDirection
    JMP @advance

@push_down:
    INC enemy_y, X
    JSR GetRandomDirection
    JMP @advance

@push_left:
    DEC enemy_x, X
    JSR GetRandomDirection
    JMP @advance

@push_right:
    INC enemy_x, X
    JSR GetRandomDirection
    JMP @advance


@get_new_direction:
    JMP GetRandomDirection
    
    JMP @advance


GetRandomDirection: 
    LDX enemy_loop_idx
    JSR GetRandom      ; returns random in A
    AND #$03           ; now A = 0,1,2,3
    ASL A              ; shift left ×2
    ASL A              ; ×4
    ASL A              ; ×8
    ASL A              ; ×16
    ASL A              ; ×32  (now A = 0, $20, $40, $60)
    STA enemy_direction, X
    RTS



GetNewEnemyRandomWalkTimer:
    LDX enemy_loop_idx

    LDA enemy_random_walk_timer, X
    CMP #$00
    BNE :+
        JSR GetRandom
        AND #$ff
        STA enemy_random_walk_timer, X
        JSR GetRandomDirection
        RTS
    :
    DEC enemy_random_walk_timer, X
    RTS


LoadEnemyCollisionValues:
    LDX enemy_loop_idx
    LDA enemy_x, X
    STA collision_check_x
    LDA enemy_y, X
    STA collision_check_y
    LDA enemy_direction, X
    STA collision_check_dir
RTS


;----------------------Enemy Draw--------------------------------------
DrawEnemies:
    LDX #$00
@loop_enemies:
    
    LDA is_enemy_active, X
    BEQ @done
    CPX enemy_count
    BCS @done

    ; LDA is_enemy_active, X
    ; BEQ @advance
    
    ; --- load this ENEMY's X/Y and precompute x+8,y+8 ---
    JMP @get_pointers

@write_sprites:
    ; compute frame offset = anim_frame * 4
    LDA anim_frame        ; 0..3
    ASL A                 ; *2
    STA tmp_frame_off

    LDY #0


    ; TL
    LDA tmpy                  ; Y
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_TILE_TL        ; tile
    CLC
    ADC tmp_frame_off
    ADC enemy_direction, X
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_ATTR           ; attr
    STA (oam_ptr_lo),Y
    INY
    LDA tmpx                  ; X
    STA (oam_ptr_lo),Y
    INY

    ; TR
    LDA tmpy
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_TILE_TR
    CLC
    ADC tmp_frame_off
    ADC enemy_direction, X
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_ATTR
    STA (oam_ptr_lo),Y
    INY
    LDA tmpx8
    STA (oam_ptr_lo),Y
    INY

    ; BL
    LDA tmpy8
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_TILE_BL
    CLC
    ADC tmp_frame_off
    ADC enemy_direction, X
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_ATTR
    STA (oam_ptr_lo),Y
    INY
    LDA tmpx
    STA (oam_ptr_lo),Y
    INY

    ; BR
    LDA tmpy8
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_TILE_BR
    CLC
    ADC tmp_frame_off
    ADC enemy_direction, X
    STA (oam_ptr_lo),Y
    INY
    LDA #ENEMY_ATTR
    STA (oam_ptr_lo),Y
    INY
    LDA tmpx8
    STA (oam_ptr_lo),Y
    ; INY not needed after last write
    JMP @advance



@advance:
    INX
    JMP @loop_enemies   
    
       ; (max 255 ENEMYs; you’ll cap earlier)
@done:
    RTS

@get_pointers:
    LDA enemy_x, X   ; X
    STA tmpx
    CLC
    ADC #8
    STA tmpx8

    LDA enemy_y,X   ; Y
    STA tmpy
    DEC tmpy
    CLC
    ADC #8
    STA tmpy8
    DEC tmpy8
    TXA
    ; --- compute OAM pointer = $0200 + ENEMY_OAM_START    TXA                       ; A = i
    ASL                       ; *2
    ASL                       ; *4
    ASL                       ; *8
    ASL                       ; *16   (16*i)
    CLC
    ADC #(4*ENEMY_OAM_START)  ; + 4*start (sprite index→byte offset)
    CLC 
    ADC #$00                  ; low of $0200
    STA oam_ptr_lo
    LDA #$02                  ; high of $0200
    ADC #$00                  ; carry won’t happen here, but keeps symmetry
    STA oam_ptr_hi
    JMP @write_sprites

; IN:  bullet_x, bullet_y, enemy_x, enemy_y (zero-page or RAM bytes)
; OUT: C=1 if overlap, C=0 if no overlap
; TRASH: A
BulletVsEnemyOverlap:
    ; if (bullet_x + 8) <= enemy_x → no hit
    LDX enemy_loop_idx 
    LDA bullet_x
    CLC
    ADC #8
    CMP enemy_x, X
    BCC @no_hit        ; A < enemy_x
    BEQ @no_hit        ; A == enemy_x

    ; if (enemy_x + 16) <= bullet_x → no hit
    LDA enemy_x, X
    CLC
    ADC #16
    CMP bullet_x
    BCC @no_hit        ; A < bullet_x
    BEQ @no_hit        ; A == bullet_x

    ; if (bullet_y + 8) <= enemy_y → no hit
    LDA bullet_y
    CLC
    ADC #8
    CMP enemy_y, X
    BCC @no_hit
    BEQ @no_hit

    ; if (enemy_y + 16) <= bullet_y → no hit
    LDA enemy_y, X
    CLC
    ADC #16
    CMP bullet_y
    BCC @no_hit
    BEQ @no_hit

    ; otherwise they overlap
    JSR Deactivate

    RTS
@no_hit:                 ; C=0 → NO HIT
    RTS


Deactivate:
    INC enemy_kill_count
    LDX enemy_loop_idx
    LDA #$00
    JSR DeactivateBullet
    STA is_enemy_active, X
    LDA #$f0
    STA enemy_y, X
    RTS


ActivateEnemies:
    LDX #$00
@loop:
    CPX enemy_count
    BEQ @done
    LDA #$01
    STA is_enemy_active, X
    TXA                      ; A = X
    ASL                      ; A = 2*X
    TAY                      ; Y = 2*X

    LDA EnemyPos, Y          ; x
    STA enemy_x, X
    INY
    LDA EnemyPos, Y          ; y
    STA enemy_y, X
    INX
    JMP @loop
@done:
RTS


LoadEnemies:
    LDX #$00
@loop:
    CPX enemy_count
    BCS @done                ; stop when X >= enemy_count

    TXA                      ; A = X
    ASL                      ; A = 2*X
    TAY                      ; Y = 2*X

    LDA EnemyPos, Y          ; x
    STA enemy_x, X
    INY
    LDA EnemyPos, Y          ; y
    STA enemy_y, X

    INX
    BNE @loop                ; (enemy_count <= 255)
@done:
    JSR ActivateEnemies
    RTS




Move_enemies_off_screen:
    ; 1) Put enemies at Y=$F0 and mark active so DrawEnemies will update OAM
    LDX #$00
@loop1:
    CPX enemy_count
    BEQ @after_draw

    LDA #$F0
    STA enemy_y, X

    LDA #$00
    STA enemy_x, X      ; (optional: could leave X as-is)
    
    LDA #$01
    STA is_enemy_active, X

    INX
    JMP @loop1

@after_draw:
    ; 2) Draw them once at the new off-screen position
    JSR DrawEnemies

    ; 3) Now mark them inactive so logic ignores them
    LDX #$00
@loop2:
    CPX enemy_count
    BEQ @done

    LDA #$00
    STA is_enemy_active, X

    INX
    JMP @loop2

@done:
    RTS


EnemyPos:
    .byte $20, $60
    .byte $60, $60
    .byte $20, $80


===== gamelogic.asm =====
.include "player.asm"
.include "input.asm"
.include "enemy.asm"
.include "chaser.asm"
.include "animate.asm"
.include "moveable_block.asm"
.include "bullet.asm"
.include "timer.asm"
.include "door.asm"
.include "gameover.asm"
.include "map_loader.asm"
.include "mimic.asm"
; .include "audio.asm"
.include "ShiftyTestTheme.asm"


INFLOOP:

@wait_vblank:
    LDA vblank_flag
    BEQ @wait_vblank
    LDA #0
    STA vblank_flag

    INC frame_counter

    ; ===== handle transition phase 2: actually load the new room =====
    LDA transition_phase
    CMP #$02
    BNE @no_load

        ; set real level from next_level
        LDA next_level
        STA level

        ; load the new level (this already handles vram_busy, $2000/$2001, etc.)
        JSR LoadLevel

        ; now switch to flicker-on phase (3)
        LDA #$03
        STA transition_phase

        LDA #16         ; flicker-on frames
        STA transition_frames

@no_load:

    ; ===== UPDATE section =====
    ; START STATE
    LDA state
    CMP #$00
    BNE :+
        JSR StartScreenStateUpdate
    :

    ; if we are in a transition, you might want to skip gameplay updates
    LDA transition_phase
    BEQ @do_game_update
    JMP @after_game_update

@do_game_update:
    ; GAME STATE
    LDA state
    CMP #$01
    BNE :+
        JSR UpdateGameLoop
    :

@after_game_update:

    ; GAME OVER STATE
    LDA state
    CMP #$02
    BNE :+
        JSR ClearOAM
    :

    JMP INFLOOP






UpdateGameLoop:
    JSR TimerUpdate
    JSR PlayerHitTimer
    JSR GetRandom
    JSR ReadController1
    JSR HandleDpad
    JSR EnemyUpdate
    JSR GetNewEnemyRandomWalkTimer
    ; JSR UpdateThunder
    JSR UpdateBulet
    JSR DoorUpdate
    JSR UpdatePlayer
    JSR UpdateMapLoader
    JSR MimicUpdate
@return:
    RTS



DrawGameLoop:

    JSR TimerDraw
    JSR DrawDoor
    JSR Undraw_door
    JSR ANITMATION
    JSR DrawEnemies
    JSR DRAWPLAYER
    JSR DrawMoveableBlock
    JSR DrawBullet   
    JSR DrawMimic

    LDA is_door_unlocked
    STA $0160
    LDA can_undraw_door
    STA $0161
    LDA door_draw_pending
    STA $0162
RTS



NMI:
LDA #$0F
STA $4015      ; force all APU channels ON every frame

    INC rand8
    PHA
    TXA
    PHA
    TYA
    PHA

    JSR famistudio_update

    LDA #1
    STA vblank_flag

    ; ===== OAM DMA =====
    LDA vram_busy
    BNE skip_dma
        LDA #$02
        STA $4014
skip_dma:

    ; ===== HANDLE TRANSITION FLICKER =====
    LDA transition_phase
    BEQ @no_transition   ; 0 = normal rendering

    CMP #$01
    BEQ @flicker_off
    CMP #$02
    BEQ @transition_dark
    CMP #$03
    BEQ @flicker_on
    JMP @no_transition

@flicker_off:
    ; phase 1: flicker, end in black + phase 2
    LDA frame_counter
    AND #%00000011
    BEQ @lights_off1
    LDA #%00011110
    JMP @write_2001_1
@lights_off1:
    LDA #$00
@write_2001_1:
    STA $2001

    DEC transition_frames
    BNE @end_transition_draw

    LDA #$00
    STA $2001       ; full black
    LDA #$02
    STA transition_phase
    JMP @end_transition_draw

@transition_dark:
    ; phase 2: keep black while main loop loads room
    LDA #$00
    STA $2001
    JMP @end_transition_draw

@flicker_on:
    ; phase 3: flicker new room, end in normal
    LDA frame_counter
    AND #%00000011
    BEQ @lights_off3
    LDA #%00011110
    JMP @write_2001_3
@lights_off3:
    LDA #$00
@write_2001_3:
    STA $2001

    DEC transition_frames
    BNE @end_transition_draw

    LDA #%00011110
    STA $2001       ; fully on
    LDA #$00
    STA transition_phase
    JMP @end_transition_draw

@end_transition_draw:
    ; while in transition, skip normal DrawGameLoop
    JMP @after_draw

@no_transition:
    ; ===== NORMAL DRAW section =====
    ; START STATE
    LDA state
    CMP #$00
    BNE :+
        JSR StartScreenStateUpdatDraw
    :

    ; GAME STATE
    LDA state
    CMP #$01
    BNE :+
        JSR DrawGameLoop
    :

    ; GAME OVER
    LDA state
    CMP #$02
    BNE :+
        JSR ClearOAM
    :


@after_draw:
    PLA
    TAY
    PLA
    TAX
    PLA
    RTI



GetRandom:
    LDA rand8
    LSR A          ; shift right, bit0 -> carry
    BCC no_xor
    EOR #$B8       ; tap polynomial

no_xor:
    STA rand8
    RTS






LoadState1:

    lda #0                 ; play song 0
    jsr famistudio_music_play


    ; JSR LoadRandomRoom
    ; JSR LOADSPRITES
    JSR LoadLevel
    ; JSR LoadEnemies
    ; JSR LoadBlocks
    ; JSR UpdateHealth
    JSR LoadPlayer
    JSR LoadMimic

    RTS



; Wait exactly one vblank/frame
WaitOneFrame:
WaitLoop:
    LDA vblank_flag
    BEQ WaitLoop
    LDA #0
    STA vblank_flag
    RTS



; ===========================
; LightsFlickerOff
;  - Flickers the lights a bit
;  - Ends with screen fully OFF ($2001 = 0)
; ===========================

LightsFlickerOff:
    LDX #16          ; number of flicker frames (tweak this)
@flicker_loop_off:
    JSR WaitOneFrame

    ; use frame_counter low bits to decide on/off
    LDA frame_counter
    AND #%00000011   ; look at last 2 bits
    BEQ @lights_off  ; ~25% of time: off

    ; lights ON this frame
    LDA #%00011110   ; BG+sprites on, your normal setting
    JMP @write_2001

@lights_off:
    LDA #$00         ; everything off

@write_2001:
    STA $2001

    DEX
    BNE @flicker_loop_off

    ; end in total darkness
    LDA #$00
    STA $2001
    RTS



; ===========================
; LightsFlickerOn
;  - Starts from black
;  - Flickers a bit
;  - Ends with screen fully ON ($2001 = %00011110)
; ===========================

LightsFlickerOn:
    LDX #16          ; number of flicker frames (tweak)

@flicker_loop_on:
    JSR WaitOneFrame

    LDA frame_counter
    AND #%00000011
    BEQ @lights_off2   ; sometimes off

    ; lights ON this frame
    LDA #%00011110
    JMP @write_2001_2

@lights_off2:
    LDA #$00

@write_2001_2:
    STA $2001

    DEX
    BNE @flicker_loop_on

    ; end with lights ON
    LDA #%00011110
    STA $2001
    RTS

===== gameover.asm =====
Gameover:
    
    JSR ClearBackground
    LDA #$02
    STA state
    JSR DrawGameover
    
    RTS



; GAMEOVER_TEXT_X = #$7b
; GAMEOVER_TEXT_Y = $#78
gameover_string:
    .byte $c6, $c0, $cc, $c4, $ce, $d5, $c4, $d1
DrawGameover:

    LDX #$00
    @loop:
        CPX #$08
        BEQ @done
            LDA gameover_string, X
            STA loadedTile

            LDY #GAMEOVER_TEXT_Y
            TXA
            PHA
            CLC
            ADC #GAMEOVER_TEXT_X
            TAX
            JSR SetBGTile
            PLA
            TAX
            INX
            JMP @loop

    @done:
        RTS

GameoverUpdate:

    JSR ReadController1
    LDA controller1_prev
    AND #STARTBTN
    BNE @done
        LDA controller1
        AND #STARTBTN
        BEQ @done
            
            LDA #$00
            STA state
            STA start_screen
            JSR LoadTitleScreenBackground
@done:
    RTS
===== header.asm =====
.byte "NES"		;identification string
.byte $1A
.byte $02		;amount of PRG ROM in 16K units
.byte $01		;amount of CHR ROM in 8K units
.byte $00		;mapper and mirroing
.byte $00, $00, $00, $00
.byte $00, $00, $00, $00, $00
===== init_vars.asm =====
INITVARS:
    LDA #$00
    STA move_timer
    STA anim_timer
    STA anim_frame
    STA vblank_flag
    STA loop_counter
    STA start_screen
    STA state
    STA is_player_hit
    STA frame_counter
    STA player_hit_timer
    STA is_player_checking
    STA enemy_kill_count
    STA timer_counter
    STA can_undraw_door
    STA last_draw_to_move_enemies
     




    ; LDA TIMER_FPS
    
    

    STA is_door_unlocked
    STA timer_s

    LDA #$01
     
    STA timer_ts
    STA can_move_block
    

LDA #$01

STA timer_tick_counter



LDA #$00
STA bullet_x
LDA #$f0
STA bullet_y
LDA #$04
STA bullet_w
STA bullet_h
LDA #$00
STA is_bullet_active
STA bullet_direction

LDA #$01
STA is_enemy_active
STA is_enemy_active+1
STA is_enemy_active+2
;     LDX #00
; @l1:
;     STA moveable_block_x, X
;     STA moveable_block_y, X
;     STA is_moveable_block_moved, X
;     INX
;     LDX #01
;     STA moveable_block_x, X
;     STA moveable_block_y, X
;     STA is_moveable_block_moved, X

;     LDX #02
;     STA moveable_block_x, X
;     STA moveable_block_y, X
;     STA is_moveable_block_moved, X

;     LDA #$60
    LDA #03
    STA enemy_count
    STA moveable_block_count
    

    LDX #$00
    LDA #$20
    STA enemy_direction, X

    LDX #$01
    LDA #$40
    STA enemy_direction, X

    LDX #$02
    LDA #$60
    STA enemy_direction, X
    
    LDA #$40
    STA enemy_direction



    LDA #PLAYER_X_START
    STA player_x
    LDA #PLAYER_Y_START
    STA player_y

    LDA #$10
    STA enemy_random_walk_timer
    STA enemy_random_walk_timer+1
    STA enemy_random_walk_timer+2

    LDA #$80
    ; STA enemy_x
    ; STA enemy_y
    STA CHASERENEMY_X
    STA CHASERENEMY_Y

    

    ; STA direction
    
 
    STA CHASERSPEEDCOUNTER

    LDA #$20
	STA player_direction

    STA CHASERDIRECTION



    LDA #$03
    STA player_health
    STA timer_m

    LDA #$00
    STA mimic_x
    LDA #$f0
    STA mimic_y
    LDA #$00
    STA level
    RTS
===== input.asm =====



ReadController1:
    LDA controller1
    STA controller1_prev
    ; Latch
    LDA #$01
    STA $4016
    LDA #$00
    STA $4016
    
    ; Build controller1 by shifting in 8 bits (LSB-first)
    LDA #$00
    STA controller1
    LDY #$08
@read_loop:
    LDA $4016        ; bit0 = current button (1 = pressed)
    LSR A            ; bit0 -> C
    ROR controller1  ; rotate C into controller1
    DEY
    BNE @read_loop
    RTS

    
HandleDpad:

    
    ; --- UP ---
    LDA controller1
    AND #UPBTN
    BEQ @down
    
    LDA #FACINGUP
    STA player_direction

    JSR Snap_x

    JSR LoadPlayerCollisionValues
    LDA #$01
    STA is_player_checking
    JSR TileCollision
    BCS @down  
    DEC player_y
    
    LDA #$00
    STA is_player_checking
    
    RTS
    
@down:
    ; --- DOWN ---
    LDA controller1
    AND #DOWNBTN
    BEQ @left

    LDA #FACINGDOWN
    STA player_direction
    JSR Snap_x

    JSR LoadPlayerCollisionValues
    LDA #$01
    STA is_player_checking
    JSR TileCollision
    BCS @left
    INC player_y
    
    LDA #$00
    STA is_player_checking
    
    RTS

@left:
    ; --- LEFT ---
    LDA controller1
    AND #LEFTBTN
    BEQ @right

    LDA #FACINGLEFT
    STA player_direction

    JSR Snap_y

    JSR LoadPlayerCollisionValues
    LDA #$01
    STA is_player_checking
    JSR TileCollision
    BCS @right
    DEC player_x
    
    LDA #$00
    STA is_player_checking
    
    RTS

@right:
    ; --- RIGHT ---
    LDA controller1
    AND #RIGHTBTN
    BEQ @start_btn

    LDA #FACINGRIGHT
    STA player_direction
    JSR Snap_y

    JSR LoadPlayerCollisionValues
    LDA #$01
    STA is_player_checking
    JSR TileCollision
    BCS @start_btn

    INC player_x
    LDA #$00
    STA is_player_checking
    
    RTS


@start_btn:
    LDA controller1
    AND #STARTBTN
    BEQ @select_btn
        
    RTS

@select_btn:
    LDA controller1
    AND #SELECTBTN
    BEQ @a_btn
        LDA #$03
        STA enemy_kill_count
    RTS

@a_btn:
    LDA controller1
    AND #ABTN
    BEQ @b_btn
        LDA player_x
        STA bullet_x
        LDA player_y
        STA bullet_y
        LDA player_direction
        STA bullet_direction
        LDA #$01
        STA is_bullet_active
    RTS

@b_btn:
    LDA controller1
    AND #BBTN
    BEQ @done
    
    RTS


@done:
    RTS



LoadPlayerCollisionValues:
    LDA player_x
    STA collision_check_x
    LDA player_y
    STA collision_check_y
    
    LDA player_direction
    STA collision_check_dir
RTS







Snap_x:
    LDA player_x
    CLC
    ADC #$04
    LSR A
    LSR A
    LSR A
    STA player_tile_x

   
   LDA player_tile_x
   ASL A
   ASL A
   ASL A
   STA player_x
RTS


Snap_y:
    LDA player_y
    CLC
    ADC #$04
    LSR A
    LSR A
    LSR A
    STA player_tile_y

   
   LDA player_tile_y
   ASL A
   ASL A
   ASL A
   STA player_y
RTS
===== levels.asm =====
.include "levels/level_1.asm"
.include "levels/level_2.asm"
.include "levels/level_3.asm"
.include "levels/level_4.asm"
.include "levels/level_5.asm"
.macro LEVEL_ENTRY bgLabel, collLabel
    .byte <bgLabel, >bgLabel, <collLabel, >collLabel
.endmacro



LevelTable:
    LEVEL_ENTRY Level_1_Data, Level_1_CollisionData   ; level = 0
    LEVEL_ENTRY Level_2_Data, Level_2_CollisionData   ; level = 1
    LEVEL_ENTRY Level_3_Data, Level_3_CollisionData   ; level = 2
    LEVEL_ENTRY Level_4_Data, Level_4_CollisionData   ; level = 2
    LEVEL_ENTRY Level_5_Data, Level_5_CollisionData   ; level = 2




===== main.asm =====
; .include "ppu.asm"
; .include "audio.asm"

.include "constants.inc"
.segment "HEADER"
	.include "header.asm"


.segment "ZEROPAGE"
.include "zeropage.asm"



.segment "STARTUP"

.include "reset.asm"
IRQ:
    RTI


    

	
.segment "CODE"
.include "collision.asm"
.include "gamelogic.asm"


.segment "VECTORS"
	.word NMI
	.word RESET
    .word IRQ
	

.segment "CHARS"
	.incbin "romx.chr"


===== map_loader.asm =====
.include "levels.asm"


; ===== LoadLevel: sets bgPtr + collPtr based on current level, then loads data =====

LoadLevel:

    ; tell NMI to stay out of VRAM
    LDA #$01
    STA vram_busy

    ; disable NMI + rendering
    LDA #$00
    STA $2000       ; NMI off
    STA $2001       ; rendering off

    ; A or memory "level" holds the current level index (0-based)
    LDA level        ; 0,1,2,...
    ASL A            ; *2
    ASL A            ; *4
    ; CLC
    ; ADC #4
    TAX              ; X = offset into LevelTable

    ; --- bgPtr = pointer to this level's BG data ---
    LDA LevelTable, X     ; BG low
    STA bgPtrLo
    INX
    LDA LevelTable, X     ; BG high
    STA bgPtrHi
    INX

    ; --- collPtr = pointer to this level's collision data ---
    LDA LevelTable, X     ; COLL low
    STA collPtrLo
    INX
    LDA LevelTable, X     ; COLL high
    STA collPtrHi

    ; now we have pointers for this level
    JSR LoadCollisionTable
    JSR LoadBackground
    JSR LoadBKAtr
    JSR TimerDraw
    LDA #$01
    STA can_draw_health
    STA can_draw_timer
    
    LDA level
    CMP #$00
    BNE :+
        JSR Level_1_init
        JMP @after_init
    :
    LDA level
    CMP #$01
    BNE :+
        JSR Level_2_init
        JMP @after_init
    :
    LDA level
    CMP #$02
    BNE :+
        JSR Level_3_init
        JMP @after_init
    :
    LDA level
    CMP #$03
    BNE :+
        JSR Level_4_init
        JMP @after_init
    :
    ; etc...

@after_init:
    ; re-enable rendering + NMI
    LDA #%00011110
    STA $2001          ; show BG+sprites
    LDA #%10010000
    STA $2000          ; NMI on, BG pattern table select as you like

    ; allow NMI to draw again
    LDA #$00
    STA vram_busy
    ; LDA #$01
    ; STA can_undraw_door

    LDA #$00
    STA is_door_unlocked
    STA door_draw_pending

    STA can_undraw_door

    RTS



; ===== LoadBackground: copy 1024 bytes from ROM → PPU nametable $2000 =====

LoadBackground:
    ; set PPU address to $2000 (nametable 0)
    LDA $2002          ; reset latch
    LDA #$20
    STA $2006
    LDA #$00
    STA $2006

    ; copy bgPtr into tempPtr so we don't modify bgPtr itself
    LDA bgPtrLo
    STA tempPtrLo
    LDA bgPtrHi
    STA tempPtrHi

    ; --- 3 full pages (3 * 256 = 768 bytes) ---
    LDY #$00
    LDX #$03           ; 3 pages

@page_loop:
@byte_loop:
    LDA (tempPtrLo), Y
    STA $2007
    INY
    BNE @byte_loop     ; when Y wraps, page done

    INC tempPtrHi      ; move to next 256-byte page
    DEX
    BNE @page_loop

    ; --- last 192 bytes (960 - 768 = 192) ---
    LDY #$00
@last_chunk:
    CPY #192           ; $C0
    BEQ @done_bg
    LDA (tempPtrLo), Y
    STA $2007
    INY
    BNE @last_chunk

@done_bg:
    ; reset scroll
    LDA #$00
    STA $2005
    STA $2005

    RTS


;LOAD BACKGROUND PALETTEDATA
	

LoadBKAtr:
    LDA #$23	
	STA $2006
	LDA #$c0
	STA $2006
	LDX #$00
    @loop:
	LDA BKAttrTableData, X
	STA $2007
	INX
	CPX #$40
	BNE @loop

	;RESET SCROLL
	LDA #$00
	STA $2005
	STA $2005
RTS


BKAttrTableData:
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	.byte $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00
	.byte $00, $00, $00, $00, $00, $00, $00, $00



LoadCollisionTable:
    LDY #$00
@copy:
    CPY #240            ; 16*15
    BEQ @done
    LDA (collPtrLo), Y  ; read from current level's collision data
    STA COLLISIONTABLE, Y
    INY
    BNE @copy
@done:
    RTS



UpdateMapLoader:
    ; Level 3 only
    LDA level
    CMP #$02
    BNE @done

    ; wait until all 3 enemies are dead
    LDA enemy_kill_count
    CMP #$03
    BNE @done

    ; already unlocked? then do nothing (avoid re-drawing each frame)
    ; LDA is_door_unlocked
    ; BNE @done

    ; first time: mark unlocked & draw door once
    LDA #$01
    STA is_door_unlocked
    STA door_draw_pending
    ; JSR DrawDoor

@done:
    RTS








; @after_init:
;     ; clear any door state carried from the previous level
    

;     ; re-enable rendering + NMI
;     LDA #%00011110
;     STA $2001          ; show BG+sprites
;     LDA #%10010000
;     STA $2000          ; NMI on, BG pattern table select as you like

;     ; allow NMI to draw again
;     LDA #$00
;     STA vram_busy

;     LDA #$00
;     STA is_door_unlocked
;     STA door_draw_pending
;     LDA #$01
;     STA can_undraw_door

;     RTS










===== mimic.asm =====

MimicUpdate:

@up:
    LDA controller1
    AND #UPBTN
    BEQ @down
        JSR LoadMimicCollisionValues   ; OK if uses A only
        JSR TileCollision 
        BCS @done
            JSR MimicSnap_x
            INC mimic_y
            JMP @done
@down:
    LDA controller1
    AND #DOWNBTN
    BEQ @right
        JSR LoadMimicCollisionValues   ; OK if uses A only
        JSR TileCollision 
        BCS @done 
            JSR MimicSnap_x
            DEC mimic_y
            JMP @done
@right:
    LDA controller1
    AND #RIGHTBTN
    BEQ @left
        JSR LoadMimicCollisionValues   ; OK if uses A only
        JSR TileCollision 
        BCS @done 
            JSR MimicSnap_y
            DEC mimic_x
            JMP @done

@left:
    LDA controller1
    AND #LEFTBTN
    BEQ @done
        JSR LoadMimicCollisionValues   ; OK if uses A only
        JSR TileCollision 
        BCS @done 
            JSR MimicSnap_y
            INC mimic_x
            JMP @done
@done:
RTS
DrawMimic:
     

    ; top row Y
    LDA mimic_y
    STA MIMIC_OAM_BASE+0    ; sprite 0 Y (TL)
    STA MIMIC_OAM_BASE+4    ; sprite 1 Y (TR)

    ; bottom row Y = MIMIC_Y + 8
   
    ADC #8
    STA MIMIC_OAM_BASE+8    ; sprite 2 Y (BL)
    STA MIMIC_OAM_BASE+12   ; sprite 3 Y (BR)

    ; --- tile indices ---
    JSR GetDirection
    LDA anim_frame
    ASL A
    CLC
    
    ADC mimic_direction
    TAX 
   
    
                    
    STX MIMIC_OAM_BASE+1 ; TL tile
    INX    
    STX MIMIC_OAM_BASE+5 ; TR tile
    TXA
    CLC
    ADC #$0f
    TAX
    STX MIMIC_OAM_BASE+9 ; BL tile
    INX              
    STX MIMIC_OAM_BASE+13 ; BR tile

    ; --- attributes (palette, priority, flips) ---

    LDA #$01                ; pick your attr
    STA MIMIC_OAM_BASE+2    ; TL
    STA MIMIC_OAM_BASE+6    ; TR
    STA MIMIC_OAM_BASE+10   ; BL
    STA MIMIC_OAM_BASE+14   ; BR

    ; --- X positions ---

    ; left column X
    LDA mimic_x
    STA MIMIC_OAM_BASE+3    ; sprite 0 X (TL)
    STA MIMIC_OAM_BASE+11   ; sprite 2 X (BL)

    ; right column X = MIMIC_X + 8
    CLC
    ADC #8
    STA MIMIC_OAM_BASE+7    ; sprite 1 X (TR)
    STA MIMIC_OAM_BASE+15   ; sprite 3 X (BR)

    RTS

GetDirection:
LDA player_direction
@up:
CMP #FACINGUP
BNE @down
    LDA #FACINGDOWN
    STA mimic_direction
    JMP @done

@down:
CMP #FACINGDOWN
BNE @right
    LDA #FACINGUP
    STA mimic_direction
    JMP @done

@right:
CMP #FACINGRIGHT
BNE @left
    LDA #FACINGLEFT
    STA mimic_direction
    JMP @done

@left:
CMP #FACINGLEFT
BNE @done
    LDA #FACINGRIGHT
    STA mimic_direction
    JMP @done


@done:
RTS



LoadMimicCollisionValues:
    LDA mimic_x
    STA collision_check_x
    LDA mimic_y
    STA collision_check_y
    LDA mimic_direction
    STA collision_check_dir
RTS



;*******************LOAD MIMIC**************************
LoadMimic:
    LDX #$00
@loop:
    LDA MimicSpriteData, X
    STA $0200 + 4*MIMIC_OAM_START, X   ; write into OAM buffer
    INX
    CPX #$10        ; 16 bytes
    BNE @loop
    RTS

MimicSpriteData:
    .byte $f0, $00, $01, $40
    .byte $f0, $01, $01, $48
    .byte $f0, $10, $01, $40
    .byte $f0, $11, $01, $48





MimicSnap_x:
    LDA mimic_x
    CLC
    ADC #$04
    LSR A
    LSR A
    LSR A
    STA mimic_tile_x

   
   LDA mimic_tile_x
   ASL A
   ASL A
   ASL A
   STA mimic_x
RTS


MimicSnap_y:
    LDA mimic_y
    CLC
    ADC #$04
    LSR A
    LSR A
    LSR A
    STA mimic_tile_y

   
   LDA mimic_tile_y
   ASL A
   ASL A
   ASL A
   STA mimic_y
RTS
===== moveable_block.asm =====
MoveBlock:
    LDA #$01
    STA is_door_unlocked
    STA door_draw_pending
    STA block_move_pending

@up:
    LDA player_direction
    CMP #FACINGUP
    BNE @down
        LDA movable_block_index
        JSR UnsetTileSolid
        LDA movable_block_index
        JSR Get_x_and_y
        
        
        LDA movable_block_floor_tile_x
        STA movable_block_new_tile_x
        LDA movable_block_floor_tile_y
        SEC
        SBC #$02
        STA movable_block_new_tile_y

        LDA movable_block_index
        SEC
        SBC #$10
        JSR SetTileSolid1
        
        JMP @done

@down:

    LDA player_direction
    CMP #FACINGDOWN
    BNE @left
        LDA movable_block_index
        JSR UnsetTileSolid
        LDA movable_block_index
        JSR Get_x_and_y
        
        
        LDA movable_block_floor_tile_x
        STA movable_block_new_tile_x
        LDA movable_block_floor_tile_y
        CLC
        ADC #$02
        STA movable_block_new_tile_y

        LDA movable_block_index
        CLC
        ADC #$10
        JSR SetTileSolid1
        
        JMP @done

@left:
    LDA player_direction
    CMP #FACINGLEFT
    BNE @right
        LDA movable_block_index
        JSR UnsetTileSolid
        LDA movable_block_index
        JSR Get_x_and_y
        
        
        LDA movable_block_floor_tile_x
        SEC
        SBC #$02
        STA movable_block_new_tile_x
        LDA movable_block_floor_tile_y
        
        STA movable_block_new_tile_y

        LDA movable_block_index
        SEC
        SBC #$01
        JSR SetTileSolid1
        
        JMP @done

@right:
    LDA player_direction
    CMP #FACINGRIGHT
    BNE @done
        LDA movable_block_index
        JSR UnsetTileSolid
        LDA movable_block_index
        JSR Get_x_and_y
        
        
        LDA movable_block_floor_tile_x
        
        CLC
        ADC #$02
        STA movable_block_new_tile_x
        LDA movable_block_floor_tile_y
        STA movable_block_new_tile_y

        LDA movable_block_index
        CLC
        ADC #$01
        JSR SetTileSolid1
        
        JMP @done

@done:
    LDA #$01
    STA block_move_pending
    LDA #$00
    STA block_move_phase  
    RTS




DrawMoveableBlock:

    LDA block_move_pending
    BEQ @done

    LDA block_move_phase
    BEQ @phase0

; ---------- phase 1: draw new block ----------
@phase1:
    ; we’re done after drawing the block
    LDA #$00
    STA block_move_pending

    JSR DrawBlock2x2
    JMP @done

; ---------- phase 0: clear old floor ----------
@phase0:
    LDA #$f4
    STA loadedTile
    JSR Draw2x2_same_tile     ; draws floor tiles

    ; advance to phase 1 for next frame
    LDA #$01
    STA block_move_phase
    JMP @done

@done:
    RTS





Get_x_and_y:
    LDA movable_block_index
    LSR A
    LSR A
    LSR A
    LSR A
    ASL A   
    
    STA movable_block_floor_tile_y   

    LDA movable_block_index
    AND #$0F
    
    ASL A   
    STA movable_block_floor_tile_x 

    RTS



Draw2x2_same_tile:
    ; TL

    LDX movable_block_floor_tile_x
    STX $00d0
    LDY movable_block_floor_tile_y
    STY $00d1

    LDA loadedTile
    JSR SetBGTile

    ; TR
    INX
    LDA loadedTile
    JSR SetBGTile

    ; BL
    DEX
    INY
    LDA loadedTile
    JSR SetBGTile

    ; BR
    INX
    LDA loadedTile
    JSR SetBGTile

    RTS


DrawBlock2x2:
    ; TL
    
    LDX movable_block_new_tile_x
    STX $00d2
    LDY movable_block_new_tile_y
    STY $00d3
    LDA #$04
    STA loadedTile
    JSR SetBGTile

    ; TR
    
    INX
    LDA #$05
    STA loadedTile
    JSR SetBGTile

    ; BL
    
    DEX
    INY
    LDA #$14
    STA loadedTile
    JSR SetBGTile

    ; BR
    
    INX
    LDA #$15
    STA loadedTile
    JSR SetBGTile

    RTS

===== player.asm =====
DRAWPLAYER:
    ; JSR DrawHealth
	LDA anim_frame
    ASL A
    CLC
    ADC player_direction
    TAX                        ; X = frame_base

    ;load next sprite for animation
    STX $0201                  ; TL
    INX
    STX $0205                  ; TR
    TXA
    CLC
    ADC #15
    TAX
    STX $0209                  ; BL
    INX
    STX $020D                  ; BR    

    LDA player_x
    STA $0203
    STA $020b
    CLC
    ADC #8
    STA $0207
    STA $020f

    LDA player_y
    STA player_y_pos

    ; decide blink
    LDA frame_counter
    AND #%00000001         ; test bit 0 (odd/even frame)
    BNE @hide               ; odd → hide

@show:
    ; top row Y = player_y_pos - 1  (NES OAM Y is spriteY+1)
    LDA player_y_pos
    SEC
    SBC #$01
    STA $0200              ; TL Y
    STA $0204              ; TR Y
    CLC
    ADC #8                 ; bottom row Y = top + 8
    STA $0208              ; BL Y
    STA $020C              ; BR Y
    JMP @done

@hide:
    LDA is_player_hit
    BEQ @show
    LDA #$FE
    STA $0200
    STA $0204
    STA $0208
    STA $020C

@done:
    RTS


UpdatePlayer:
    LDA player_health
    BNE :+
        JSR Gameover
    :

    LDX #$00
    @loop:
    CPX enemy_count
    BEQ @done
        LDA enemy_y, X
        LSR
        LSR
        LSR
        LSR         ; A = tile_y
        STA tile_y

        LDA enemy_x, X
        LSR
        LSR
        LSR
        LSR         ; A = tile_x
        STA tile_x

        LDA tile_y
        ASL
        ASL
        ASL
        ASL         ; A = y*16
        CLC
        ADC tile_x
        STA tmp_tile
        
        JSR GetPlayerTile
        LDA tmp_tile
        CMP player_tile
        BNE @next
            LDA is_player_hit
            BNE @next
            LDA #HitTimer
            STA player_hit_timer
            LDA #$01
            STA is_player_hit
            DEC player_health
            STA can_draw_health
            ; JSR UpdateHealth


    @next:
        INX
        JMP @loop

@done:
RTS



GetPlayerTile:
    LDA player_y
    LSR
    LSR
    LSR
    LSR         ; A = tile_y
    STA player_tile_y

    LDA player_x
    LSR
    LSR
    LSR
    LSR         ; A = tile_x
    STA player_tile_x

    LDA player_tile_y
    ASL
    ASL
    ASL
    ASL         ; A = y*16
    CLC
    ADC player_tile_x
    STA player_tile

    RTS


DrawHealth:

    ; Only draw when flagged
    ; LDA can_draw_health
    ; CMP #$01
    ; BNE @done

    ; LDA #$00
    ; STA can_draw_health

    ; Clamp player_health to MAX_HEALTH just in case
    LDA player_health
    CMP #MAX_HEALTH
    BCC :+
        LDA #MAX_HEALTH
        STA player_health
    :

    ; --- set PPU address to start of health bar ---
    LDA PPUSTATUS          ; $2002, reset latch
    LDA #HEALTH_ADDR_HI
    STA PPUADDR            ; $2006 high
    LDA #HEALTH_ADDR_LO
    STA PPUADDR            ; $2006 low

    ; --- draw MAX_HEALTH tiles in a row ---
    LDX #$00               ; heart index

@health_loop:
    CPX #MAX_HEALTH
    BCS @done_write

    ; choose tile: heart if X < player_health, else blank
    CPX player_health
    BCC @heart_tile

@blank_tile:
    LDA #$00               ; blank tile index
    BEQ @emit              ; always taken

@heart_tile:
    LDA #HEALTH_TILE       ; heart tile index

@emit:
    STA PPUDATA            ; $2007

    INX
    JMP @health_loop

@done_write:
@done:

	LDA #$00
    STA $2005
    STA $2005
    RTS





PlayerHitTimer:
    ; --- hit flash timer (safe, no underflow) ---
    LDA is_player_hit
    BEQ @done                ; not active → skip

    LDA player_hit_timer
    BEQ @clear               ; already 0 → clear & stop

    DEC player_hit_timer     ; count down once per frame
    LDA player_hit_timer
    
    BNE @done                ; still >0 → done

@clear:
    LDA #$00
    STA is_player_hit
    STA player_hit_timer     ; keep it at 0

@done:
    RTS






LoadPlayer:
    LDX #$00
    @loop:
        LDA PlayerSpriteData, X
        STA $0200, X
        INX
        CPX #$10	;16bytes (4 bytes per sprite, 8 sprites total)
        BNE @loop
        
    RTS

    PlayerSpriteData:
    ;   $Y, $SpriteI, $attrs, $X


        ;Player_________________________
        .byte PLAYER_Y_START, $00, $00, PLAYER_X_START
        .byte PLAYER_Y_START, $01, $00, (PLAYER_X_START+8)
        .byte (PLAYER_Y_START+8), $10, $00, PLAYER_X_START
        .byte (PLAYER_Y_START+8), $11, $00, (PLAYER_X_START+8)





===== ppu.asm =====

===== reset.asm =====
.include "init_vars.asm"
.include "background.asm"
; .include "test_room.asm"
.include "sprites.asm"
; .include "random_room.asm"
.include "start_screen.asm"
.include "famistudio_ca65.s"


RESET:
	SEI 		;disables interupts
	CLD			;turn off decimal mode
	
	LDX #%1000000	;disable sound IRQ
	STX $4017
	LDX #$00
	STX $4010		;disable PCM
	
	;initialize the stack register
	LDX #$FF
	TXS 		;transfer x to the stack
	
	; Clear PPU registers
	LDX #$00
	STX $2000
	STX $2001
	
	;WAIT FOR VBLANK
:
	BIT $2002
	BPL :-
	
	;CLEARING 2K MEMORY
	TXA
CLEARMEMORY:		;$0000 - $07FF
	STA $0000, X
	STA $0100, X
	STA $0300, X
	STA $0400, X
	STA $0500, X
	STA $0600, X
	STA $0700, X
		LDA #$FF
		STA $0200, X
		LDA #$00
	INX
	CPX #$00
	BNE CLEARMEMORY

; --- PPU Warmup: wait 2 vblanks ---
    BIT $2002
@vb1:
    BIT $2002
    BPL @vb1
@vb2:
    BIT $2002
    BPL @vb2

	

	;SETTING SPRITE RANGE
	LDA #$02
	STA $4014
	NOP
	
	
	;load background pallet
	LDA $2002
	LDA #$3F	;$3F00
	STA $2006
	LDA #$00
	STA $2006
	
	LDX #$00

LOADPALETTES:
	LDA PALETTEDATA, X
	STA $2007
	INX
	CPX #$20
	BNE LOADPALETTES

JSR INITVARS




; JSR LOADBACKGROUND
JSR LoadTitleScreenBackground
; LDA #10         ; place 10 random blocks
; LDX #$04        ; meta-tile TL id = $04
; JSR LoadRandomRoom


	CLI

	LDA #%10010000
	STA $2000			;WHEN VBLANK OCCURS CALL NMI

	LDA #%00011110		;show sprites and background
	STA $2001

	lda #%00001111
	sta $4015

		; X/Y = address of music data
	; A   = 1 for NTSC, 0 for PAL
	LDX #<music_data_untitled
	LDY #>music_data_untitled
	LDA #1          ; NTSC
	JSR famistudio_init






	JMP INFLOOP



===== ShiftyTestTheme.asm =====
; This file is for the FamiStudio Sound Engine and was generated by FamiStudio
; Required flags for Untitled:
.segment "CODE"

.segment "RODATA"


.export _music_data_untitled:=music_data_untitled

music_data_untitled:
	.byte 1
	.word @instruments
	.word @samples-4
; 00 : Song 1
	.word @song0ch0
	.word @song0ch1
	.word @song0ch2
	.word @song0ch3
	.word @song0ch4
	.byte .lobyte(@tempo_env_1_mid), .hibyte(@tempo_env_1_mid), 0, 0

.export music_data_untitled
.global FAMISTUDIO_DPCM_PTR

@instruments:
	.word @env1,@env2,@env4,@env0 ; 00 : Instrument 1
	.word @env5,@env3,@env4,@env6 ; 01 : Instrument 2

@env0:
	.byte $00,$c0,$7f,$00,$02
@env1:
	.byte $00,$cf,$7f,$00,$02
@env2:
	.byte $c0,$7f,$00,$01
@env3:
	.byte $d4,$cf,$db,$e2,$a8,$d3,$cb,$c0,$00,$07
@env4:
	.byte $7f,$00,$00
@env5:
	.byte $00,$cd,$ca,$c7,$c4,$c3,$c2,$c0,$00,$07
@env6:
	.byte $00,$cc,$a2,$d5,$a0,$c0,$9d,$e3,$bf,$00,$08

@samples:

@tempo_env_1_mid:
	.byte $03,$05,$80

@song0ch0:
@song0ch0loop:
	.byte $47, .lobyte(@tempo_env_1_mid), .hibyte(@tempo_env_1_mid), $80
@song0ref6:
	.byte $19, $a5, $20, $a5, $25, $a5, $28, $a5, $27, $a5, $1f, $a5, $2b, $a5, $00, $a5, $48, $19, $a5, $20, $a5, $25, $a5, $28
	.byte $a5, $27, $a5, $2f, $a5, $23, $a5, $00, $a5, $48
	.byte $41, $10
	.word @song0ref6
	.byte $48, $2c, $a5, $2b, $a5, $28, $a5, $27, $a5, $25, $a5, $27, $a5, $28, $a5, $27, $a5, $48, $00, $ff, $ff, $bd
@song0ref65:
	.byte $48, $ff, $ff, $bf, $48, $ff, $ff, $bf, $48, $ff, $ff, $bf, $48, $ff, $ff, $bf, $48, $ff, $ff, $bf
	.byte $41, $0f
	.word @song0ref65
	.byte $48, $ff, $ff, $bf, $42
	.word @song0ch0loop
@song0ch1:
@song0ch1loop:
	.byte $80
@song0ref97:
	.byte $27, $a5, $28, $a5, $2b, $a5, $2c, $a5, $2d, $a5, $2c, $a5, $2b, $a5, $28, $a5, $3b, $a5, $39, $a5, $38, $a5, $36, $a5
	.byte $38, $a5, $39, $a5, $3b, $a5, $39, $a5
	.byte $41, $10
	.word @song0ref97
	.byte $34, $a5, $33, $a5, $31, $a5, $2f, $a5, $2d, $a5, $2c, $a5, $2d, $a5, $2f, $a5
@song0ref148:
	.byte $00, $ff, $ff, $bd
@song0ref152:
	.byte $ff, $ff, $bf, $ff, $ff, $bf, $ff, $ff, $bf, $ff, $ff, $bf, $ff, $ff, $bf
	.byte $41, $0f
	.word @song0ref152
	.byte $ff, $ff, $bf, $42
	.word @song0ch1loop
@song0ch2:
@song0ch2loop:
	.byte $80
@song0ref178:
	.byte $0d, $a5, $10, $a5, $0f, $a5, $13, $a5, $0d, $a5, $10, $a5, $0f, $a5, $08, $a5
	.byte $41, $10
	.word @song0ref178
	.byte $41, $10
	.word @song0ref178
	.byte $41, $10
	.word @song0ref178
	.byte $41, $13
	.word @song0ref148
	.byte $41, $0f
	.word @song0ref152
	.byte $ff, $ff, $bf, $42
	.word @song0ch2loop
@song0ch3:
@song0ch3loop:
	.byte $82, $40, $01
@song0ref219:
	.byte $a5, $17, $a5, $10, $a5, $19, $a5, $1f, $a5, $1a, $a5, $1f, $a5, $17
	.byte $41, $0e
	.word @song0ref219
	.byte $a5, $00
	.byte $41, $0e
	.word @song0ref219
	.byte $a5, $00
	.byte $41, $0e
	.word @song0ref219
	.byte $a5, $00, $a5
	.byte $41, $0f
	.word @song0ref152
	.byte $41, $0f
	.word @song0ref152
	.byte $ff, $ff, $bf, $ff, $ff, $bf, $42
	.word @song0ch3loop
@song0ch4:
@song0ch4loop:
	.byte $41, $0f
	.word @song0ref152
	.byte $41, $0f
	.word @song0ref152
	.byte $41, $0f
	.word @song0ref152
	.byte $ff, $ff, $bf, $42
	.word @song0ch4loop

===== sprites.asm =====

LOADSPRITES:
    LDX #$00
    LOADSPRITESMEM:
        LDA SPRITEDATA, X
        STA $0200, X
        INX
        CPX #$10	;16bytes (4 bytes per sprite, 8 sprites total)
        BNE LOADSPRITESMEM
        
    RTS

    SPRITEDATA:
    ;   $Y, $SpriteI, $attrs, $X


        ;Player_________________________
        .byte $40, $00, $00, $40
        .byte $40, $01, $00, $48
        .byte $48, $10, $00, $40
        .byte $48, $11, $00, $48
    

        ;     ;bound box
        ; .byte $40, $82, $02, $3f
        ; .byte $40, $83, $02, $47
        ; .byte $48, $92, $02, $3f
        ; .byte $48, $93, $02, $47
        

        ;ENEMY
        ; .byte $80, $08, $2, $80
        ; .byte $80, $09, $2, $88
        ; .byte $88, $18, $2, $80
        ; .byte $88, $19, $2, $88

        ;ENEMY Chaser
        ; .byte $90, $08, $3, $90
        ; .byte $90, $09, $3, $98
        ; .byte $98, $18, $3, $90
        ; .byte $98, $19, $3, $98
        ; ;window
        ; .byte $10, $08, $01, $90
        ; .byte $10, $09, $01, $98
        ; .byte $18, $18, $01, $90
        ; .byte $18, $19, $01, $98
        ; .byte $20, $28, $01, $90
        ; .byte $20, $29, $01, $98
        ; .byte $28, $38, $01, $90
        ; .byte $28, $39, $01, $98
        
        

        ; ; ;Blocks
        ; .byte $60, $82, $00, $60
        ; .byte $60, $83, $00, $68
        ; .byte $68, $92, $00, $60
        ; .byte $68, $93, $00, $68

   

        ; 2 if frames are laid out across, 32 if vertical


    ; ===== TL-only animator, explicit labels =====
    



===== start_screen.asm =====
; ; Load full title screen: nametable + attributes
; Assumes your BG tiles are in $1000 (tile $80 == $1800)
; and you’ve already loaded the palettes elsewhere.

LoadTitleScreenBackground:
    

    ; --- rendering/NMI OFF while we touch VRAM ---
    LDA #$00
    STA $2001                    ; render off
    LDA #%00010000               ; NMI=0, inc=+1, BG=$1000, NT=$2000
    STA $2000

    ; (optional) wait one vblank on cold boot
@vb: BIT $2002
     BPL @vb

    ; --- NAMETABLE: $2000..$23BF (960 bytes) ---
    LDA $2002                    ; reset latch before $2006 pair
    LDA #$20 
    STA $2006
    LDA #$00
    STA $2006

    ; page 0 (0..255)
    LDX #$00
@pg0: LDA TitleScreenData, X
      STA $2007
      INX
      BNE @pg0

    ; page 1 (256..511)
    LDX #$00
@pg1: LDA TitleScreenData+256, X
      STA $2007
      INX
      BNE @pg1

    ; page 2 (512..767)
    LDX #$00
@pg2: LDA TitleScreenData+512, X
      STA $2007
      INX
      BNE @pg2

    ; tail (768..959) 192 bytes
    LDX #$00
@tail:
      LDA TitleScreenData+768, X
      STA $2007
      INX
      CPX #192
      BNE @tail

    ; --- ATTRIBUTES: $23C0..$23FF (64 bytes) ---
    LDA $2002                    ; reset latch before $2006 pair
    LDA #$23
    STA $2006
    LDA #$C0
    STA $2006

    LDX #$00
@attr:
      LDA LoadAttrTableData, X
      STA $2007
      INX
      CPX #$40
      BNE @attr

    ; --- reset scroll and SHOW ---
    LDA #$00
    STA $2005
    STA $2005

    LDA #%00011110               ; BG+sprites on
    STA $2001
    LDA #%10010000               ; NMI on, inc=+1, BG=$1000, NT=$2000
    STA $2000

    RTS

	
LoadAttrTableData:
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff
    .byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff





TitleScreenData:
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00

    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$21,$22,$00,$00,$00,$26,$27,$28,$29,$00,$00,$00,$21,$22,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$3a,$23,$30,$31,$32,$33,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$4a,$63,$60,$41,$41,$54,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$50,$51,$52,$53,$53,$55,$56,$57,$58,$59,$5a,$53,$53,$51,$52,$64,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$50,$61,$62,$53,$53,$65,$66,$67,$68,$69,$6a,$53,$53,$61,$62,$64,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$70,$71,$72,$73,$73,$75,$76,$77,$78,$79,$7a,$73,$73,$71,$72,$74,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00,$00,$00,$00,$00,$00,$00

    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$80,$81,$82,$83,$84,$85,$86,$87,$88,$89,$a8,$a9,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$90,$91,$92,$93,$94,$95,$96,$97,$98,$99,$b8,$b9,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$a0,$a1,$a2,$a3,$a4,$a5,$80,$81,$84,$85,$a6,$a7,$a4,$a5,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$b0,$b1,$b2,$b3,$b4,$b5,$90,$91,$94,$95,$b6,$b7,$b4,$b5,$00,$00,$00,$00,$00,$00,$00,$00

    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00

    .byte $00,$00,$00,$cf,$d1,$c4,$d2,$d2,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$d2,$d3,$c0,$d1,$d3,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00


    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    .byte $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    






    StartScreenStateUpdate:
    JSR ReadController1

    ; if *any* button is pressed, set start_screen=1 once
    LDA start_screen
    BNE @skip                ; already set

    LDA controller1_prev
    AND #STARTBTN
    BNE @skip
        LDA controller1
        AND #STARTBTN
        BEQ @skip
    LDA #$01
    STA start_screen

    JSR LoadState1

    
@skip:
    ; advance state if start_screen==1
    LDA start_screen
    CMP #$01
    BNE :+
        INC state
        
        ; STA start_screen
        
    :
    RTS


StartScreenStateUpdatDraw:
    ; LDA #$00
    ; STA $2000
    ; STA $2001  
    RTS
    


===== timer.asm =====
TimerUpdate:
    DEC timer_tick_counter
    LDA timer_tick_counter
    BNE @skip

        LDA #TIMER_FPS
        STA timer_tick_counter ;reset
        
        LDA #$01
        STA can_draw_timer
        
        ;get timer_s
        LDA timer_s
        BNE :+
            LDA #$09
            STA timer_s
            DEC timer_ts
        ;dec timer_s
        :

        LDA timer_ts
        BNE :+
            LDA #$05
            STA timer_ts
            DEC timer_m
        :
    
    DEC timer_s
    
@skip:
    RTS


TimerDraw:
    LDA can_draw_timer
    CMP #$01
    BNE @done

    LDA #$00
    STA can_draw_timer

    LDX timer_m
    LDA NumberTiles, X
    STA loadedTile
    LDY #TIMER_DIGIT_Y
    LDX #TIMER_DIGIT_X1
    JSR SetBGTile
    
    
    LDX timer_ts
    LDA NumberTiles, X
    STA loadedTile
    LDY #TIMER_DIGIT_Y
    LDX #TIMER_DIGIT_X2
    JSR SetBGTile

    LDX timer_s
    LDA NumberTiles, X
    STA loadedTile
    LDY #TIMER_DIGIT_Y
    LDX #TIMER_DIGIT_X3
    JSR SetBGTile


    LDX level
    INX
    LDA NumberTiles, X
    STA loadedTile
    LDY #TIMER_DIGIT_Y
    LDX #LEVEL_X
    JSR SetBGTile

    JSR DrawHealth

@done:
    RTS

NumberTiles:
    .byte $d9,$da,$db,$dc,$dd,$de,$df,$e0,$e1,$e2



 
===== zeropage.asm =====
; ===== ZEROPAGE: tiny & hot stuff only =====
.segment "ZEROPAGE"
vblank_flag:        .res 1
controller1:        .res 1
controller1_prev:   .res 1
rand8:              .res 1

tmp:                .res 1   ; scratch
tile_x:             .res 1
tile_y:             .res 1
tmp_tile:.res 1
cur_tile: .res 1
moveable_block_x: .res 3
moveable_block_y: .res 3
moveable_block_count: .res 1

target_idx: .res 1
tx:         .res 1   

is_player_checking: .res 1
is_player_hit: .res 1
player_hit_timer: .res 1
player_y_pos: .res 1
frame_counter: .res 1

; tmp_push_block_x: .res 1
; tmp_push_block_y: .res 1
is_moveable_block_moved: .res 3

collide_check_1x: .res 1
collide_check_1y: .res 1


collide_check_2x: .res 1
collide_check_2y: .res 1


t1_minx: .res 1
t1_maxx: .res 1
t1_miny: .res 1
t1_maxy: .res 1
t2_minx: .res 1
t2_maxx: .res 1
t2_miny: .res 1
t2_maxy: .res 1



bullet_x: .res 1
bullet_y: .res 1
bullet_w: .res 1
bullet_h: .res 1
bullet_direction: .res 1
is_bullet_active: .res 1

timer_counter: .res 1
timer_tick_counter: .res 1

gameover: .res 1

player_x: .res 1
player_y: .res 1
player_tile_x: .res 1
player_tile_y: .res 1
player_tile: .res 1
player_direction: .res 1
player_health: .res 1

tmp_frame_off: .res 1


enemy_x: .res 3
enemy_y: .res 3
enemy_direction: .res 3
enemy_random_walk_timer: .res 3
is_enemy_active: .res 3
enemy_count: .res 1
enemy_kill_count: .res 1

CHASERENEMY_X: .res 1
CHASERENEMY_Y: .res 1

CHASERENEMYDIRECTION: .res 1
CHASERSPEEDCOUNTER: .res 1
CHASERDIRECTION: .res 1


collision_check_x: .res 1
collision_check_y: .res 1

collision_check_dir: .res 1


move_timer:  .res 1
anim_timer:  .res 1
anim_frame:  .res 1



rand_col: .res 1
rand_row: .res 1

loop_counter: .res 1


tmp0: .res 1
tmp1: .res 1
loadedTile: .res 1

random_seed: .res 1
button_pressed: .res 1
start_screen: .res 1

state: .res 1
vram_busy: .res 1


oam_ptr_lo: .res 1
oam_ptr_hi: .res 1
tmpx:       .res 1
tmpx8:      .res 1
tmpy:       .res 1
tmpy8:      .res 1

enemy_loop_idx: .res 1

timer_s: .res 1
timer_ts: .res 1
timer_m: .res 1
level: .res 1


bgPtrLo:   .res 1
bgPtrHi:   .res 1
collPtrLo: .res 1
collPtrHi: .res 1
tempPtrLo: .res 1
tempPtrHi: .res 1

can_move_block: .res 1
is_block_moved_for_unlock: .res 1
temp_col: .res 1
current_tile_index: .res 1


mimic_direction: .res 1
mimic_x: .res 1
mimic_y: .res 1
player_x_prev: .res 1
player_y_prev: .res 1
tmp_delta: .res 1
mimic_tile_x: .res 1
mimic_tile_y: .res 1

block_move_pending: .res 1
block_to_index: .res 1
block_from_index: .res 1
can_undraw_door: .res 1
meta_row: .res 1
meta_col: .res 1
door_draw_pending: .res 1

can_draw_timer: .res 1



movable_block_floor_tile_x: .res 1
movable_block_floor_tile_y: .res 1
movable_block_new_tile_x: .res 1
movable_block_new_tile_y: .res 1
block_move_phase: .res 1
movable_block_index: .res 1
can_draw_health: .res 1
health_tmp: .res 1


transition_phase:   .res 1   ; 0 = no transition, 1 = flicker off, 2 = load room, 3 = flicker on
transition_frames:  .res 1
next_level:         .res 1

last_draw_to_move_enemies: .res 1


thunder_active: .res 1
thunder_timer: .res 1

.segment "BSS"

COLLISIONTABLE: .res 240




; bgPtr       = $10        ; 2 bytes: low + high
; bgPtrLo     = bgPtr
; bgPtrHi     = bgPtr+1

; collPtr     = $12
; collPtrLo   = collPtr
; collPtrHi   = collPtr+1

; tempPtrLo = $14
; tempPtrHi = $15

hundreds: .res 1
tens:     .res 1
ones:     .res 1

secret_tile: .res 1
is_door_unlocked: .res 1
